# **LIFE TIME FITNESS - GYM PERSONALIZATION APP**
## **Complete Implementation Package for Code Pilot Claude Sonnet 4.5**

---

# **ğŸ“‹ TABLE OF CONTENTS**

1. **Project Overview & Objectives**
2. **Technical Stack & Architecture**
3. **Implementation Plan (Phased Approach)**
4. **Detailed Technical Specifications**
5. **Code Pilot Prompts (Ready to Use)**
6. **API Specifications**
7. **Database Schema**
8. **Infrastructure & DevOps**
9. **Testing Strategy**
10. **Demo Scenarios**

---

# **1. PROJECT OVERVIEW & OBJECTIVES**

## **Project Name:** FitLife Personalization Engine

## **Business Goal:**
Build a proof-of-concept personalization system that recommends gym classes, workouts, and content to members based on their preferences, behavior, and fitness goals.

## **Why This Project Matters for the Interview:**
- **Demonstrates system design skills** (microservices, event-driven architecture)
- **Shows full-stack proficiency** (.NET Core + Vue.js)
- **Proves cloud/DevOps knowledge** (Azure, Kafka, Kubernetes)
- **Exhibits senior-level thinking** (scalability, trade-offs, maintainability)
- **Directly relevant** to the Personalization/Pega rebuild team at Life Time

## **Key Features:**
1. âœ… User profile management (fitness level, goals, preferences)
2. âœ… Class catalog with filtering and search
3. âœ… Personalized class recommendations (rule-based algorithm)
4. âœ… Event tracking (views, clicks, bookings)
5. âœ… Real-time dashboard showing user activity
6. âœ… Admin panel for managing classes and viewing analytics
7. âœ… Responsive Vue.js frontend
8. âœ… RESTful API with .NET Core
9. âœ… Event streaming with Kafka
10. âœ… Containerized with Docker/Kubernetes

---

# **2. TECHNICAL STACK & ARCHITECTURE**

## **Backend:**
- **.NET Core 8** (Web API)
- **C# 12** (latest features)
- **Entity Framework Core** (ORM)
- **Azure SQL Database** (production) / **SQL Server** (local dev)
- **Redis** (caching layer)
- **Kafka** (event streaming)
- **Dapper** (high-performance queries when needed)

## **Frontend:**
- **Vue.js 3** (Composition API)
- **TypeScript** (type safety)
- **Pinia** (state management)
- **Vue Router** (routing)
- **Axios** (HTTP client)
- **Tailwind CSS** (styling)
- **Chart.js** (data visualization)

## **Infrastructure:**
- **Docker** (containerization)
- **Kubernetes** (orchestration)
- **Azure Container Registry** (image storage)
- **Azure App Service / AKS** (hosting)
- **Azure Event Hubs** (Kafka-compatible)
- **GitHub Actions** (CI/CD)

## **Development Tools:**
- **Visual Studio 2022 / VS Code**
- **Postman** (API testing)
- **Docker Desktop** (local dev)
- **Azure CLI** (cloud management)
- **k9s** (Kubernetes management)

---

## **High-Level Architecture Diagram**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         FRONTEND LAYER                           â”‚
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Vue.js 3 SPA (Tailwind CSS)                            â”‚  â”‚
â”‚  â”‚  - Member Dashboard                                      â”‚  â”‚
â”‚  â”‚  - Class Browser & Booking                              â”‚  â”‚
â”‚  â”‚  - User Profile & Preferences                           â”‚  â”‚
â”‚  â”‚  - Recommendations Feed                                 â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚ HTTPS / REST
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      API GATEWAY LAYER                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Nginx / Azure API Management (optional)                â”‚  â”‚
â”‚  â”‚  - Rate limiting                                        â”‚  â”‚
â”‚  â”‚  - Authentication (JWT)                                 â”‚  â”‚
â”‚  â”‚  - Request routing                                      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    BACKEND API LAYER (.NET Core 8)              â”‚
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ User Service   â”‚  â”‚ Class Service  â”‚  â”‚ Rec Service    â”‚   â”‚
â”‚  â”‚ - Auth         â”‚  â”‚ - CRUD         â”‚  â”‚ - Generate     â”‚   â”‚
â”‚  â”‚ - Profile      â”‚  â”‚ - Search       â”‚  â”‚ - Score        â”‚   â”‚
â”‚  â”‚ - Preferences  â”‚  â”‚ - Schedule     â”‚  â”‚ - Rank         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚          â”‚                   â”‚                    â”‚             â”‚
â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                              â”‚                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚                                 â”‚
              â–¼                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   CACHE LAYER        â”‚          â”‚   EVENT STREAM       â”‚
â”‚   Redis              â”‚          â”‚   Kafka              â”‚
â”‚   - Recommendations  â”‚          â”‚   - user-events      â”‚
â”‚   - User sessions    â”‚          â”‚   - system-events    â”‚
â”‚   - Popular classes  â”‚          â”‚                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚                              â”‚
              â”‚                              â”‚
              â–¼                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    BACKGROUND WORKERS (.NET Core)                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Event Consumer â”‚  â”‚ Rec Generator   â”‚  â”‚  User Profiler  â”‚ â”‚
â”‚  â”‚ - Process      â”‚  â”‚ - Batch compute â”‚  â”‚  - Segmentation â”‚ â”‚
â”‚  â”‚   events       â”‚  â”‚ - Cache update  â”‚  â”‚  - Analytics    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DATA LAYER (Azure SQL / SQL Server)           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Users   â”‚ â”‚  Classes â”‚ â”‚ Interact â”‚ â”‚ Recommendations  â”‚  â”‚
â”‚  â”‚          â”‚ â”‚          â”‚ â”‚  -ions   â”‚ â”‚  (precomputed)   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# **3. IMPLEMENTATION PLAN (PHASED APPROACH)**

## **PHASE 1: Foundation (Week 1) - "Get Something Running"**

### **Goal:** 
Basic CRUD API + Simple frontend + Database + Docker setup

### **Deliverables:**
- âœ… .NET Core Web API project structure
- âœ… Entity Framework Core with SQL Server
- âœ… Basic models (User, Class, Interaction)
- âœ… CRUD endpoints for Users and Classes
- âœ… Vue.js project with Vite
- âœ… Basic pages (Home, Classes List, User Profile)
- âœ… Docker Compose for local development
- âœ… Basic authentication (JWT)

### **Tasks:**
1. **Backend Setup (Day 1-2)**
   - Create .NET Core Web API solution
   - Add EF Core and configure DbContext
   - Create database migrations
   - Implement User and Class controllers
   - Add JWT authentication middleware

2. **Frontend Setup (Day 3-4)**
   - Initialize Vue.js project with TypeScript
   - Set up Tailwind CSS
   - Create layout components (Header, Sidebar, Footer)
   - Implement authentication flow (login/register)
   - Build Classes list page with API integration

3. **Infrastructure Setup (Day 5)**
   - Create Docker Compose file
   - Configure Redis container
   - Configure SQL Server container
   - Set up environment variables
   - Test end-to-end flow locally

### **Success Criteria:**
- Can create/read users and classes via API
- Frontend displays classes from database
- User can log in and see personalized dashboard
- Everything runs in Docker locally

---

## **PHASE 2: Core Features (Week 2) - "Make It Useful"**

### **Goal:**
Add event tracking, basic recommendations, and enhanced UI

### **Deliverables:**
- âœ… Event tracking API (clicks, views, bookings)
- âœ… Basic recommendation algorithm (rule-based)
- âœ… Recommendation endpoint with caching
- âœ… Enhanced Vue.js UI with recommendations feed
- âœ… User preferences management
- âœ… Class search and filtering

### **Tasks:**
1. **Event Tracking (Day 1-2)**
   - Create Interactions table and model
   - Implement event tracking endpoint
   - Add event types (View, Click, Book, Complete)
   - Store events in database
   - Create analytics queries

2. **Recommendations Engine (Day 3-4)**
   - Implement rule-based scoring algorithm
   - Create user segmentation logic
   - Build recommendation generation service
   - Add Redis caching for recommendations
   - Create background job for batch processing

3. **Frontend Enhancements (Day 5)**
   - Build recommendations feed component
   - Add class filtering and search
   - Implement user preferences page
   - Add interaction tracking to UI
   - Create loading states and error handling

### **Success Criteria:**
- Events are tracked when users interact with classes
- Users see personalized recommendations
- Recommendations are cached and fast (<200ms)
- UI is responsive and polished

---

## **PHASE 3: Event Streaming (Week 3) - "Scale It Up"**

### **Goal:**
Replace direct database writes with Kafka event streaming

### **Deliverables:**
- âœ… Kafka integration (local with Docker)
- âœ… Event producer in API
- âœ… Event consumer background service
- âœ… Async event processing
- âœ… Event replay capability

### **Tasks:**
1. **Kafka Setup (Day 1-2)**
   - Add Kafka to Docker Compose
   - Install Confluent.Kafka NuGet package
   - Create Kafka producer service
   - Create topics (user-events, system-events)
   - Test message publishing

2. **Event Producer (Day 3)**
   - Modify event tracking endpoint to publish to Kafka
   - Add event schema validation
   - Implement retry logic for failed publishes
   - Add correlation IDs for tracing

3. **Event Consumer (Day 4-5)**
   - Create background worker service
   - Consume events from Kafka topics
   - Process events (save to database)
   - Update user profiles based on events
   - Trigger recommendation refresh

### **Success Criteria:**
- Events flow through Kafka instead of direct DB writes
- Event consumer processes messages in near real-time
- System handles 1000+ events/minute
- Failed events are retried

---

## **PHASE 4: Production Ready (Week 4) - "Ship It"**

### **Goal:**
Kubernetes deployment, monitoring, CI/CD, and documentation

### **Deliverables:**
- âœ… Kubernetes manifests (deployments, services, ingress)
- âœ… Helm charts (optional, for easier deployment)
- âœ… GitHub Actions CI/CD pipeline
- âœ… Health checks and metrics endpoints
- âœ… Logging with structured logs
- âœ… README and architecture docs

### **Tasks:**
1. **Kubernetes Setup (Day 1-2)**
   - Create Kubernetes manifests for API
   - Create manifests for background workers
   - Configure persistent volumes for SQL/Redis
   - Set up Ingress for external access
   - Add ConfigMaps and Secrets

2. **CI/CD Pipeline (Day 3)**
   - Create GitHub Actions workflow
   - Build and push Docker images
   - Run tests in pipeline
   - Deploy to Kubernetes cluster
   - Add environment-specific configs

3. **Observability (Day 4)**
   - Add health check endpoints
   - Implement structured logging (Serilog)
   - Add metrics (Prometheus-compatible)
   - Create simple monitoring dashboard
   - Set up alerts for errors

4. **Documentation (Day 5)**
   - Write comprehensive README
   - Document API endpoints (Swagger)
   - Create architecture diagrams
   - Write deployment guide
   - Record demo video

### **Success Criteria:**
- Application runs in Kubernetes
- CI/CD deploys automatically on push
- Logs are structured and searchable
- Health checks work correctly
- Documentation is clear and complete

---

# **4. DETAILED TECHNICAL SPECIFICATIONS**

## **4.1 Backend API Specification**

### **Project Structure:**

```
FitLife.Api/
â”œâ”€â”€ Controllers/
â”‚   â”œâ”€â”€ UsersController.cs
â”‚   â”œâ”€â”€ ClassesController.cs
â”‚   â”œâ”€â”€ RecommendationsController.cs
â”‚   â”œâ”€â”€ EventsController.cs
â”‚   â””â”€â”€ AuthController.cs
â”œâ”€â”€ Models/
â”‚   â”œâ”€â”€ User.cs
â”‚   â”œâ”€â”€ Class.cs
â”‚   â”œâ”€â”€ Interaction.cs
â”‚   â”œâ”€â”€ Recommendation.cs
â”‚   â””â”€â”€ DTOs/
â”‚       â”œâ”€â”€ LoginRequest.cs
â”‚       â”œâ”€â”€ RegisterRequest.cs
â”‚       â”œâ”€â”€ ClassResponse.cs
â”‚       â””â”€â”€ RecommendationResponse.cs
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ IUserService.cs
â”‚   â”œâ”€â”€ UserService.cs
â”‚   â”œâ”€â”€ IRecommendationService.cs
â”‚   â”œâ”€â”€ RecommendationService.cs
â”‚   â”œâ”€â”€ IEventService.cs
â”‚   â”œâ”€â”€ EventService.cs
â”‚   â””â”€â”€ ScoringEngine.cs
â”œâ”€â”€ Data/
â”‚   â”œâ”€â”€ FitLifeDbContext.cs
â”‚   â”œâ”€â”€ Repositories/
â”‚   â”‚   â”œâ”€â”€ IUserRepository.cs
â”‚   â”‚   â”œâ”€â”€ UserRepository.cs
â”‚   â”‚   â”œâ”€â”€ IClassRepository.cs
â”‚   â”‚   â””â”€â”€ ClassRepository.cs
â”‚   â””â”€â”€ Migrations/
â”œâ”€â”€ Infrastructure/
â”‚   â”œâ”€â”€ Kafka/
â”‚   â”‚   â”œâ”€â”€ KafkaProducer.cs
â”‚   â”‚   â””â”€â”€ KafkaConsumer.cs
â”‚   â”œâ”€â”€ Redis/
â”‚   â”‚   â””â”€â”€ RedisCacheService.cs
â”‚   â””â”€â”€ Authentication/
â”‚       â””â”€â”€ JwtService.cs
â”œâ”€â”€ BackgroundServices/
â”‚   â”œâ”€â”€ EventConsumerService.cs
â”‚   â”œâ”€â”€ RecommendationGeneratorService.cs
â”‚   â””â”€â”€ UserProfilerService.cs
â”œâ”€â”€ Program.cs
â””â”€â”€ appsettings.json
```

---

### **4.2 Core Models**

```csharp
// Models/User.cs
public class User
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Email { get; set; } = string.Empty;
    public string PasswordHash { get; set; } = string.Empty;
    public string FirstName { get; set; } = string.Empty;
    public string LastName { get; set; } = string.Empty;
    public string FitnessLevel { get; set; } = "Beginner"; // Beginner, Intermediate, Advanced
    public string Goals { get; set; } = string.Empty; // JSON array
    public string PreferredClassTypes { get; set; } = string.Empty; // JSON array
    public string FavoriteInstructors { get; set; } = string.Empty; // JSON array
    public string Segment { get; set; } = "General"; // Calculated by profiler
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
    
    // Navigation properties
    public ICollection<Interaction> Interactions { get; set; } = new List<Interaction>();
    public ICollection<Recommendation> Recommendations { get; set; } = new List<Recommendation>();
}

// Models/Class.cs
public class Class
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Name { get; set; } = string.Empty;
    public string Type { get; set; } = string.Empty; // Yoga, Spin, HIIT, Pilates, etc.
    public string Description { get; set; } = string.Empty;
    public string InstructorId { get; set; } = string.Empty;
    public string InstructorName { get; set; } = string.Empty;
    public string LocationId { get; set; } = "default";
    public string LocationName { get; set; } = string.Empty;
    public DateTime StartTime { get; set; }
    public int DurationMinutes { get; set; }
    public int Capacity { get; set; }
    public int CurrentEnrollment { get; set; }
    public decimal AverageRating { get; set; }
    public string DifficultyLevel { get; set; } = "All Levels";
    public string ImageUrl { get; set; } = string.Empty;
    public bool IsActive { get; set; } = true;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
}

// Models/Interaction.cs
public class Interaction
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string UserId { get; set; } = string.Empty;
    public string ItemId { get; set; } = string.Empty;
    public string ItemType { get; set; } = "Class"; // Class, Workout, Article
    public string EventType { get; set; } = string.Empty; // View, Click, Book, Complete, Cancel
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
    public string Metadata { get; set; } = "{}"; // JSON for additional context
    
    // Navigation
    public User? User { get; set; }
}

// Models/Recommendation.cs
public class Recommendation
{
    public string UserId { get; set; } = string.Empty;
    public string ItemId { get; set; } = string.Empty;
    public string ItemType { get; set; } = "Class";
    public double Score { get; set; }
    public int Rank { get; set; }
    public string Reason { get; set; } = string.Empty; // Explanation for user
    public DateTime GeneratedAt { get; set; } = DateTime.UtcNow;
    
    // Navigation
    public User? User { get; set; }
    public Class? Class { get; set; }
}
```

---

### **4.3 API Endpoints**

#### **Authentication**

```
POST /api/auth/register
POST /api/auth/login
POST /api/auth/refresh
GET  /api/auth/me
```

#### **Users**

```
GET    /api/users/{id}
PUT    /api/users/{id}
GET    /api/users/{id}/preferences
PUT    /api/users/{id}/preferences
GET    /api/users/{id}/activity
```

#### **Classes**

```
GET    /api/classes
GET    /api/classes/{id}
POST   /api/classes (admin only)
PUT    /api/classes/{id} (admin only)
DELETE /api/classes/{id} (admin only)
GET    /api/classes/search?query=yoga&type=Yoga&date=2025-10-30
GET    /api/classes/upcoming
```

#### **Recommendations**

```
GET    /api/recommendations/{userId}?type=class&limit=10
POST   /api/recommendations/refresh/{userId}
GET    /api/recommendations/{userId}/explain/{itemId}
```

#### **Events**

```
POST   /api/events
GET    /api/events/{userId}?limit=50
GET    /api/events/analytics
```

#### **Health & Monitoring**

```
GET    /health
GET    /health/ready
GET    /metrics
```

---

### **4.4 Key Services Implementation**

#### **ScoringEngine.cs**

```csharp
public class ScoringEngine
{
    public double CalculateScore(User user, Class classItem)
    {
        double score = 0;
        
        // Factor 1: Fitness level match
        if (IsLevelMatch(user.FitnessLevel, classItem.DifficultyLevel))
            score += 10;
        
        // Factor 2: Class type preference
        var preferredTypes = JsonSerializer.Deserialize<List<string>>(user.PreferredClassTypes) ?? new();
        if (preferredTypes.Contains(classItem.Type))
            score += 15;
        
        // Factor 3: Instructor preference
        var favoriteInstructors = JsonSerializer.Deserialize<List<string>>(user.FavoriteInstructors) ?? new();
        if (favoriteInstructors.Contains(classItem.InstructorId))
            score += 20;
        
        // Factor 4: Time preference (check user's typical booking times)
        if (IsPreferredTime(user, classItem.StartTime))
            score += 8;
        
        // Factor 5: Popularity (high rating)
        score += classItem.AverageRating * 2;
        
        // Factor 6: Availability (penalize if almost full)
        var availabilityRatio = (double)(classItem.Capacity - classItem.CurrentEnrollment) / classItem.Capacity;
        if (availabilityRatio < 0.2)
            score -= 5; // Almost full
        
        // Factor 7: Segment-based boost
        score += GetSegmentBoost(user.Segment, classItem.Type);
        
        return Math.Max(0, score);
    }
    
    private bool IsLevelMatch(string userLevel, string classLevel)
    {
        if (classLevel == "All Levels") return true;
        return userLevel == classLevel;
    }
    
    private bool IsPreferredTime(User user, DateTime classTime)
    {
        // Simplified: check if class time matches user's historical booking patterns
        // In production, analyze user's interaction history
        var hour = classTime.Hour;
        
        // Morning person: 5-9 AM
        // Evening person: 5-9 PM
        // Weekend warrior: Sat/Sun any time
        
        return hour >= 17 && hour <= 21; // Default to evening preference
    }
    
    private double GetSegmentBoost(string segment, string classType)
    {
        return segment switch
        {
            "YogaEnthusiast" when classType == "Yoga" => 12,
            "StrengthTrainer" when classType == "HIIT" || classType == "Strength" => 12,
            "CardioLover" when classType == "Spin" || classType == "Running" => 12,
            "HighlyActive" => 5, // Boost all types for very active users
            _ => 0
        };
    }
}
```

---

## **4.5 Frontend Structure**

```
fitlife-web/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ assets/
â”‚   â”‚   â”œâ”€â”€ images/
â”‚   â”‚   â””â”€â”€ styles/
â”‚   â”‚       â””â”€â”€ main.css
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ layout/
â”‚   â”‚   â”‚   â”œâ”€â”€ AppHeader.vue
â”‚   â”‚   â”‚   â”œâ”€â”€ AppSidebar.vue
â”‚   â”‚   â”‚   â””â”€â”€ AppFooter.vue
â”‚   â”‚   â”œâ”€â”€ classes/
â”‚   â”‚   â”‚   â”œâ”€â”€ ClassCard.vue
â”‚   â”‚   â”‚   â”œâ”€â”€ ClassList.vue
â”‚   â”‚   â”‚   â”œâ”€â”€ ClassFilter.vue
â”‚   â”‚   â”‚   â””â”€â”€ ClassDetails.vue
â”‚   â”‚   â”œâ”€â”€ recommendations/
â”‚   â”‚   â”‚   â”œâ”€â”€ RecommendationFeed.vue
â”‚   â”‚   â”‚   â””â”€â”€ RecommendationCard.vue
â”‚   â”‚   â”œâ”€â”€ user/
â”‚   â”‚   â”‚   â”œâ”€â”€ ProfileForm.vue
â”‚   â”‚   â”‚   â”œâ”€â”€ PreferencesForm.vue
â”‚   â”‚   â”‚   â””â”€â”€ ActivityTimeline.vue
â”‚   â”‚   â””â”€â”€ common/
â”‚   â”‚       â”œâ”€â”€ LoadingSpinner.vue
â”‚   â”‚       â”œâ”€â”€ ErrorAlert.vue
â”‚   â”‚       â””â”€â”€ Modal.vue
â”‚   â”œâ”€â”€ views/
â”‚   â”‚   â”œâ”€â”€ HomeView.vue
â”‚   â”‚   â”œâ”€â”€ LoginView.vue
â”‚   â”‚   â”œâ”€â”€ RegisterView.vue
â”‚   â”‚   â”œâ”€â”€ DashboardView.vue
â”‚   â”‚   â”œâ”€â”€ ClassesView.vue
â”‚   â”‚   â”œâ”€â”€ ProfileView.vue
â”‚   â”‚   â””â”€â”€ RecommendationsView.vue
â”‚   â”œâ”€â”€ stores/
â”‚   â”‚   â”œâ”€â”€ auth.ts
â”‚   â”‚   â”œâ”€â”€ classes.ts
â”‚   â”‚   â”œâ”€â”€ recommendations.ts
â”‚   â”‚   â””â”€â”€ user.ts
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ api.ts
â”‚   â”‚   â”œâ”€â”€ authService.ts
â”‚   â”‚   â”œâ”€â”€ classService.ts
â”‚   â”‚   â””â”€â”€ recommendationService.ts
â”‚   â”œâ”€â”€ router/
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”œâ”€â”€ User.ts
â”‚   â”‚   â”œâ”€â”€ Class.ts
â”‚   â”‚   â””â”€â”€ Recommendation.ts
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ formatters.ts
â”‚   â”‚   â””â”€â”€ validators.ts
â”‚   â”œâ”€â”€ App.vue
â”‚   â””â”€â”€ main.ts
â”œâ”€â”€ public/
â”œâ”€â”€ package.json
â”œâ”€â”€ vite.config.ts
â”œâ”€â”€ tsconfig.json
â””â”€â”€ tailwind.config.js
```

---

# **5. CODE PILOT PROMPTS (READY TO USE)**

Below are detailed prompts you can feed to Claude Sonnet 4.5 in Code Pilot mode to build this application step-by-step.

---

## **PROMPT 1: Initialize Backend Project**

```
Create a new .NET Core 8 Web API project for a gym class recommendation system called "FitLife".

Requirements:
1. Create solution structure with these projects:
   - FitLife.Api (main API project)
   - FitLife.Core (domain models and interfaces)
   - FitLife.Infrastructure (data access, external services)

2. Install these NuGet packages:
   - Microsoft.EntityFrameworkCore.SqlServer
   - Microsoft.EntityFrameworkCore.Design
   - Microsoft.AspNetCore.Authentication.JwtBearer
   - Swashbuckle.AspNetCore (Swagger)
   - StackExchange.Redis
   - Confluent.Kafka
   - Serilog.AspNetCore

3. Set up the project with:
   - Clean architecture principles
   - Dependency injection
   - Configuration management (appsettings.json)
   - CORS enabled for local development
   - Swagger UI at /swagger

4. Create appsettings.json with placeholders for:
   - SQL Server connection string
   - JWT settings (secret, issuer, audience)
   - Redis connection string
   - Kafka bootstrap servers

5. Configure Program.cs with:
   - Service registrations
   - Middleware pipeline
   - Database context
   - Authentication/Authorization
   - Swagger

Please create all necessary files and provide the complete project structure.
```

---

## **PROMPT 2: Create Domain Models and DbContext**

```
Based on the FitLife.Api project, create the domain models and Entity Framework DbContext.

Models needed:
1. User:
   - Id (string, GUID)
   - Email (string, unique)
   - PasswordHash (string)
   - FirstName, LastName
   - FitnessLevel (Beginner/Intermediate/Advanced)
   - Goals (JSON string array)
   - PreferredClassTypes (JSON string array)
   - FavoriteInstructors (JSON string array)
   - Segment (string, calculated field)
   - CreatedAt, UpdatedAt (DateTime)

2. Class:
   - Id (string, GUID)
   - Name, Description
   - Type (Yoga, Spin, HIIT, Pilates, etc.)
   - InstructorId, InstructorName
   - LocationId, LocationName
   - StartTime (DateTime)
   - DurationMinutes (int)
   - Capacity, CurrentEnrollment (int)
   - AverageRating (decimal)
   - DifficultyLevel (string)
   - ImageUrl (string)
   - IsActive (bool)
   - CreatedAt (DateTime)

3. Interaction:
   - Id (string, GUID)
   - UserId (foreign key)
   - ItemId (string)
   - ItemType (Class/Workout/Article)
   - EventType (View/Click/Book/Complete/Cancel)
   - Timestamp (DateTime)
   - Metadata (JSON string)

4. Recommendation:
   - UserId (foreign key)
   - ItemId (foreign key)
   - ItemType (string)
   - Score (double)
   - Rank (int)
   - Reason (string)
   - GeneratedAt (DateTime)
   - Composite primary key (UserId, ItemId)

Create:
1. All model classes in FitLife.Core/Models/
2. FitLifeDbContext with DbSets for all models
3. Configure relationships and indexes in OnModelCreating
4. Create initial migration
5. Add seed data for 20 sample classes (variety of types, times, instructors)

Ensure proper navigation properties and foreign key constraints.
```

---

## **PROMPT 3: Implement Authentication**

```
Implement JWT-based authentication for the FitLife API.

Requirements:
1. Create IJwtService interface and JwtService implementation:
   - GenerateToken(User user): returns JWT token string
   - ValidateToken(string token): returns ClaimsPrincipal or null
   - Token should include: userId, email, role claims
   - Token expiration: 24 hours

2. Create AuthController with endpoints:
   - POST /api/auth/register
     * Input: { email, password, firstName, lastName, fitnessLevel }
     * Validate email format and password strength
     * Hash password with BCrypt
     * Create user in database
     * Return JWT token
   
   - POST /api/auth/login
     * Input: { email, password }
     * Verify credentials
     * Return JWT token
   
   - GET /api/auth/me
     * Requires authentication
     * Return current user's profile

3. Configure authentication in Program.cs:
   - Add JWT authentication middleware
   - Configure token validation parameters
   - Set default authentication scheme

4. Create [Authorize] attribute usage examples on controllers

5. Add password hashing utility using BCrypt.Net

Provide complete, working code with proper error handling.
```

---

## **PROMPT 4: Implement CRUD Controllers**

```
Create RESTful controllers for Users and Classes in the FitLife API.

1. UsersController:
   - GET /api/users/{id} - Get user profile
   - PUT /api/users/{id} - Update user profile
   - GET /api/users/{id}/preferences - Get preferences
   - PUT /api/users/{id}/preferences - Update preferences
   - GET /api/users/{id}/activity - Get recent interactions
   - All endpoints require authentication
   - Users can only access their own data (except admins)

2. ClassesController:
   - GET /api/classes - List all classes (with pagination)
   - GET /api/classes/{id} - Get single class
   - GET /api/classes/search - Search with filters (type, date, instructor)
   - GET /api/classes/upcoming - Get upcoming classes (next 7 days)
   - POST /api/classes - Create class (admin only)
   - PUT /api/classes/{id} - Update class (admin only)
   - DELETE /api/classes/{id} - Soft delete (admin only)

Requirements:
- Use repository pattern (create IUserRepository, IClassRepository)
- Implement proper error handling with appropriate HTTP status codes
- Add input validation with Data Annotations
- Return DTOs instead of raw entities
- Add XML comments for Swagger documentation
- Implement pagination for list endpoints (page, pageSize parameters)
- Add sorting and filtering capabilities

Create:
1. Repository interfaces and implementations
2. DTOs for requests and responses
3. AutoMapper profiles for entity-to-DTO mapping
4. Controllers with all endpoints
5. Validation attributes

Provide complete, production-ready code.
```

---

## **PROMPT 5: Build Recommendation Engine**

```
Implement the recommendation engine for FitLife that scores and ranks gym classes for users.

Create these services:

1. IScoringEngine interface and ScoringEngine class:
   - CalculateScore(User user, Class classItem): double
   - Scoring factors (assign weights):
     * Fitness level match: +10 points
     * Preferred class type: +15 points
     * Favorite instructor: +20 points
     * Time preference match: +8 points
     * Class rating: rating * 2 points
     * Availability (penalize if <20% spots left): -5 points
     * User segment boost: up to +12 points
   
2. IRecommendationService interface and RecommendationService class:
   - GenerateRecommendations(string userId, int limit): Task<List<RecommendationDto>>
   - RefreshRecommendations(string userId): Task
   - GetRecommendationExplanation(string userId, string itemId): Task<string>
   
   Logic:
   a. Fetch user profile and segment
   b. Get candidate classes (upcoming, not full, user hasn't booked)
   c. Score each candidate using ScoringEngine
   d. Sort by score descending
   e. Take top N
   f. Generate human-readable reason for each recommendation
   g. Cache results in Redis (10 minute expiration)
   h. Save to Recommendations table for persistence

3. RecommendationsController:
   - GET /api/recommendations/{userId}?type=class&limit=10
     * Check Redis cache first
     * If miss, check database
     * If still empty, call GenerateRecommendations
     * Return recommendations with reasons
   
   - POST /api/recommendations/refresh/{userId}
     * Force regeneration of recommendations
     * Clear cache
     * Return new recommendations

4. User segmentation logic:
   - Analyze user's interaction history (last 30 days)
   - Assign segment based on behavior:
     * "HighlyActive": 5+ classes/week
     * "YogaEnthusiast": >60% yoga classes
     * "StrengthTrainer": >60% strength/HIIT classes
     * "CardioLover": >60% cardio classes
     * "WeekendWarrior": only weekend bookings
     * "Beginner": new user (<5 total classes)
     * "General": default

Requirements:
- Use Redis for caching (StackExchange.Redis)
- Implement cache-aside pattern
- Add logging for scoring decisions
- Handle edge cases (new users, no upcoming classes)
- Include fallback to popular classes if no personalized recs

Provide complete implementation with detailed comments explaining the scoring logic.
```

---

## **PROMPT 6: Implement Event Tracking**

```
Create event tracking system for FitLife to capture user interactions.

1. Create EventsController:
   - POST /api/events
     * Input: { userId, itemId, itemType, eventType, metadata }
     * Event types: View, Click, Book, Complete, Cancel
     * Save to Interactions table
     * Publish to Kafka topic "user-events"
     * Return 202 Accepted
   
   - GET /api/events/{userId}?limit=50
     * Get recent interactions for user
     * Sort by timestamp descending
     * Return paginated results

2. Create IEventService interface and EventService:
   - TrackEvent(InteractionDto): Task
   - GetUserEvents(string userId, int limit): Task<List<InteractionDto>>
   - GetEventAnalytics(): Task<Dictionary<string, int>>

3. Implement Kafka producer:
   - Create IKafkaProducer interface
   - Create KafkaProducer class using Confluent.Kafka
   - ProduceAsync(string topic, object message): Task
   - Handle serialization to JSON
   - Implement retry logic (3 attempts with exponential backoff)
   - Log failures

4. Event schema (JSON):
   {
     "eventId": "string",
     "userId": "string",
     "itemId": "string",
     "itemType": "string",
     "eventType": "string",
     "timestamp": "ISO 8601",
     "metadata": { }
   }

5. Update frontend tracking (create TypeScript service):
   - trackClassView(classId)
   - trackClassClick(classId)
   - trackClassBooking(classId)
   - Automatically call when user interacts with UI

Requirements:
- Async, non-blocking event publishing
- Proper error handling (don't fail request if Kafka is down)
- Structured logging with correlation IDs
- Add middleware to track API response times
- Create analytics endpoint showing event counts by type

Provide complete implementation with Kafka configuration.
```

---

## **PROMPT 7: Create Background Services**

```
Implement background worker services for FitLife that process events and generate recommendations.

Create these background services (inherit from BackgroundService):

1. EventConsumerService:
   - Subscribe to Kafka topic "user-events"
   - Consume messages continuously
   - For each event:
     * Validate event schema
     * Save to Interactions table
     * Update user's last active timestamp
     * If event is "Book", update class enrollment count
     * Log processing
   - Handle errors gracefully (log and continue)
   - Commit offsets after successful processing

2. RecommendationGeneratorService:
   - Run every 10 minutes using Timer
   - Batch process users (1000 at a time)
   - For each user:
     * Generate recommendations using RecommendationService
     * Save to Recommendations table
     * Update cache in Redis
   - Track progress (users processed, time taken)
   - Log statistics after each run

3. UserProfilerService:
   - Run every 30 minutes
   - Analyze user interaction history (last 30 days)
   - Calculate user segment based on behavior patterns
   - Update User.Segment field
   - Log segment distribution statistics

Configuration:
- Add settings to appsettings.json for timing intervals
- Make batch sizes configurable
- Add circuit breaker for external dependencies
- Implement graceful shutdown (finish current batch)

Requirements:
- Use IHostedService interface
- Proper cancellation token handling
- Structured logging with context
- Health checks for each service
- Metrics collection (events processed, errors, duration)

Register all services in Program.cs with proper lifecycle management.

Provide complete implementation with error handling and logging.
```

---

## **PROMPT 8: Initialize Vue.js Frontend**

```
Create a Vue.js 3 frontend for FitLife gym application using TypeScript and Tailwind CSS.

Initialize project with:
1. Vite as build tool
2. Vue Router for navigation
3. Pinia for state management
4. Axios for HTTP requests
5. Tailwind CSS for styling
6. Chart.js for data visualization

Project structure:
- src/
  - assets/ (images, styles)
  - components/ (reusable components)
  - views/ (page components)
  - stores/ (Pinia stores)
  - services/ (API services)
  - router/ (routing configuration)
  - types/ (TypeScript interfaces)
  - utils/ (helper functions)

Configure:
1. Tailwind with custom theme (fitness-themed colors)
2. Axios base URL and interceptors (for auth token)
3. Router with these routes:
   - / (Home - public)
   - /login (Login page)
   - /register (Register page)
   - /dashboard (User dashboard - protected)
   - /classes (Browse classes - protected)
   - /recommendations (Personalized feed - protected)
   - /profile (User profile - protected)

4. Create auth store with Pinia:
   - State: user, token, isAuthenticated
   - Actions: login, register, logout, fetchCurrentUser
   - Store token in localStorage
   - Auto-attach token to Axios requests

5. Create API service layer:
   - authService.ts (login, register, getMe)
   - classService.ts (getClasses, getClass, searchClasses)
   - recommendationService.ts (getRecommendations, trackEvent)

6. Create layout components:
   - AppHeader (with navigation, user menu)
   - AppSidebar (navigation links)
   - AppFooter

7. Create base components:
   - Button.vue (reusable button with variants)
   - Input.vue (form input with validation)
   - Card.vue (content card)
   - Modal.vue (dialog)
   - LoadingSpinner.vue
   - ErrorAlert.vue

Provide:
- Complete project setup commands
- All configuration files (vite.config.ts, tailwind.config.js, tsconfig.json)
- Base layout and routing
- Auth flow implementation
- API service abstractions
- TypeScript interfaces for models

Make it production-ready with proper error handling and loading states.
```

---

## **PROMPT 9: Build Frontend Components**

```
Create Vue.js components for the FitLife application.

Build these feature components:

1. ClassCard.vue:
   - Props: class object
   - Display: class name, instructor, time, type, duration, rating, availability
   - Visual: use Tailwind cards with hover effects
   - Show badge for difficulty level
   - Display enrollment (X/Y spots filled)
   - "Book Now" button
   - Image thumbnail
   - Click to view details
   - Emit events: @click, @book

2. ClassList.vue:
   - Props: classes array, loading state
   - Display grid of ClassCard components (3 columns on desktop)
   - Show loading skeleton while fetching
   - Show empty state if no classes
   - Pagination controls
   - Sort dropdown (by time, rating, popularity)

3. ClassFilter.vue:
   - Filter by class type (dropdown with checkboxes)
   - Filter by date (date picker)
   - Filter by time of day (morning/afternoon/evening)
   - Filter by instructor (searchable dropdown)
   - Filter by difficulty level
   - "Clear All" button
   - Emit @filter-change with selected filters

4. RecommendationCard.vue:
   - Similar to ClassCard but includes:
   - Score visualization (progress bar or stars)
   - Personalization reason ("Because you love yoga")
   - "Why this?" tooltip with explanation
   - Track view event when card appears in viewport (use Intersection Observer)

5. RecommendationFeed.vue:
   - Fetch recommendations on mount
   - Display list of RecommendationCard components
   - Show loading state
   - Refresh button
   - Empty state ("No recommendations yet")
   - Track scroll depth

6. ProfileForm.vue:
   - Form fields:
     * First name, last name
     * Email (read-only)
     * Fitness level (select dropdown)
     * Goals (multi-select chips: weight loss, strength, flexibility, cardio)
     * Preferred class types (multi-select)
   - Validation
   - Save button with loading state
   - Success/error toast messages

7. PreferencesForm.vue:
   - Favorite instructors (searchable multi-select)
   - Preferred class times (checkbox groups: morning, afternoon, evening)
   - Preferred days (checkbox: Mon-Sun)
   - Notifications settings (toggle switches)
   - Save button

Requirements:
- Use Composition API with <script setup>
- TypeScript for all components
- Proper props validation
- Emits declaration
- Accessibility (ARIA labels, keyboard navigation)
- Responsive design (mobile-first)
- Loading and error states
- Use Tailwind utility classes
- Add transitions/animations

Provide complete, well-commented components.
```

---

## **PROMPT 10: Build View Pages**

```
Create page-level components (views) for FitLife application.

1. DashboardView.vue:
   - Layout: 2 columns on desktop, stacked on mobile
   - Left column:
     * Welcome message with user's name
     * Quick stats cards (classes this week, total classes, streak)
     * Upcoming booked classes (next 3)
   - Right column:
     * Personalized recommendations feed (top 5)
     * "View All Recommendations" link
   - Recent activity timeline (last 10 interactions)
   - Fetch data on mount
   - Loading states for each section
   - Refresh button

2. ClassesView.vue:
   - Page header with title "Browse Classes"
   - ClassFilter component (sidebar on desktop, collapsible on mobile)
   - ClassList component (main content area)
   - Pagination
   - Search bar (search by class name or instructor)
   - Fetch classes on mount
   - Update when filters change
   - Show count "Showing X of Y classes"
   - Track "class_list_viewed" event

3. RecommendationsView.vue:
   - Page header "Recommended For You"
   - Description text explaining personalization
   - RecommendationFeed component
   - Filters: type (all/classes/workouts/articles)
   - Sort: by score, by time
   - "Refresh Recommendations" button
   - Track "recommendations_viewed" event

4. ProfileView.vue:
   - Tabs: Profile | Preferences | Activity
   - Profile tab:
     * User info with avatar
     * ProfileForm component
     * Change password section
   - Preferences tab:
     * PreferencesForm component
     * Export data button
   - Activity tab:
     * Activity timeline
     * Stats charts (classes per week, favorite types)
   - Save changes across tabs

5. LoginView.vue:
   - Centered card layout
   - Logo/branding
   - Login form (email, password)
   - "Remember me" checkbox
   - "Forgot password?" link
   - Submit button with loading state
   - Validation errors
   - "Don't have an account? Register" link
   - Redirect to dashboard after login

6. RegisterView.vue:
   - Similar layout to LoginView
   - Registration form (email, password, confirm password, first name, last name, fitness level)
   - Password strength indicator
   - Terms of service checkbox
   - Submit button
   - Redirect to dashboard after registration
   - "Already have an account? Login" link

Requirements:
- Use Composition API with <script setup>
- Proper data fetching with try-catch
- Loading states (skeleton screens)
- Error handling (display user-friendly messages)
- Track page views in analytics
- Responsive layout
- Navigation guards (redirect if not authenticated)
- SEO meta tags (use vue-meta or similar)

Provide complete implementation for all views.
```

---

## **PROMPT 11: Docker & Kubernetes Setup**

```
Create Docker and Kubernetes configuration for deploying FitLife application.

1. Create Dockerfiles:

   a. Dockerfile for .NET API (FitLife.Api):
      - Multi-stage build
      - Base image: mcr.microsoft.com/dotnet/aspnet:8.0
      - Build image: mcr.microsoft.com/dotnet/sdk:8.0
      - Copy source, restore, build, publish
      - Expose port 8080
      - Health check endpoint
      - Non-root user

   b. Dockerfile for Vue.js frontend:
      - Multi-stage build
      - Build stage: node:18-alpine
      - Production stage: nginx:alpine
      - Copy built files to nginx html directory
      - Custom nginx.conf for SPA routing
      - Expose port 80

2. Create docker-compose.yml for local development:
   - Services:
     * fitlife-api (API service)
     * fitlife-web (frontend)
     * sqlserver (SQL Server 2022)
     * redis (Redis 7)
     * kafka (Confluent Kafka)
     * zookeeper (required for Kafka)
   - Networks: fitlife-network
   - Volumes for persistence (SQL data, Redis data)
   - Environment variables
   - Port mappings
   - Health checks

3. Create Kubernetes manifests:

   a. api-deployment.yaml:
      - Deployment with 3 replicas
      - Resource limits (CPU, memory)
      - Liveness and readiness probes
      - Environment variables (ConfigMap and Secrets)
      - Rolling update strategy

   b. api-service.yaml:
      - ClusterIP service
      - Port 8080

   c. web-deployment.yaml:
      - Deployment with 2 replicas
      - Nginx container

   d. web-service.yaml:
      - LoadBalancer service
      - Port 80

   e. redis-deployment.yaml:
      - StatefulSet
      - Persistent volume claim

   f. sql-deployment.yaml:
      - StatefulSet
      - Persistent volume claim
      - InitContainer for schema migration

   g. kafka-deployment.yaml:
      - StatefulSet
      - Persistent volume claim

   h. configmap.yaml:
      - Application settings
      - Kafka topics
      - Redis configuration

   i. secrets.yaml:
      - Database connection string
      - JWT secret
      - API keys

   j. ingress.yaml:
      - Nginx ingress
      - Routes:
        * / -> web-service
        * /api/* -> api-service
      - TLS configuration (optional)

4. Create Helm chart (optional but recommended):
   - Chart.yaml
   - values.yaml (configurable parameters)
   - Templates for all Kubernetes resources

5. Create .dockerignore files

6. Create scripts:
   - build.sh (build all Docker images)
   - deploy.sh (deploy to Kubernetes)
   - local-dev.sh (start docker-compose)

Requirements:
- All containers should run as non-root
- Use multi-stage builds for smaller images
- Add labels for monitoring
- Configure resource limits
- Use health checks
- Enable horizontal pod autoscaling
- Add network policies for security

Provide complete, production-ready configurations with comments.
```

---

## **PROMPT 12: CI/CD Pipeline**

```
Create GitHub Actions CI/CD pipeline for FitLife application.

Create .github/workflows/ directory with these workflows:

1. backend-ci.yml:
   Trigger: push to main, pull requests to main (paths: FitLife.Api/**)
   Jobs:
   - build:
     * Checkout code
     * Setup .NET 8
     * Restore dependencies
     * Build solution
     * Run unit tests
     * Run integration tests
     * Generate code coverage report
     * Upload coverage to Codecov
   
   - security-scan:
     * Run OWASP dependency check
     * Run static code analysis (SonarCloud)
   
   - docker-build:
     * Build Docker image
     * Run container security scan (Trivy)
     * Push to Azure Container Registry (on main only)
     * Tag with commit SHA and 'latest'

2. frontend-ci.yml:
   Trigger: push to main, pull requests to main (paths: fitlife-web/**)
   Jobs:
   - build:
     * Checkout code
     * Setup Node.js
     * Install dependencies
     * Run linter (ESLint)
     * Run type check (TypeScript)
     * Build production bundle
     * Run unit tests (Vitest)
     * Check bundle size
   
   - docker-build:
     * Build Docker image
     * Push to Azure Container Registry

3. deploy.yml:
   Trigger: workflow_dispatch, push to main (after CI passes)
   Jobs:
   - deploy-staging:
     * Download Docker images
     * Update Kubernetes manifests with new image tags
     * Apply manifests to staging cluster
     * Run smoke tests
     * Notify team (Slack/email)
   
   - deploy-production:
     * Requires manual approval
     * Deploy to production cluster
     * Run health checks
     * Rollback on failure
     * Notify team

4. Create reusable workflows for common tasks

5. Add repository secrets:
   - AZURE_CONTAINER_REGISTRY_URL
   - AZURE_CONTAINER_REGISTRY_USERNAME
   - AZURE_CONTAINER_REGISTRY_PASSWORD
   - KUBE_CONFIG_STAGING
   - KUBE_CONFIG_PRODUCTION
   - SLACK_WEBHOOK_URL

6. Create branch protection rules:
   - Require CI to pass
   - Require code review
   - No force push to main

Requirements:
- Fast CI (use caching for dependencies)
- Parallel jobs where possible
- Clear job names and status checks
- Fail fast on errors
- Comprehensive test coverage
- Security scanning
- Automatic rollback on failure
- Notifications

Provide complete workflow files with comments.
```

---

# **6. API SPECIFICATION (OpenAPI/Swagger)**

```yaml
openapi: 3.0.0
info:
  title: FitLife Personalization API
  version: 1.0.0
  description: API for gym class recommendations and user management

servers:
  - url: http://localhost:8080/api
    description: Local development
  - url: https://api.fitlife.example.com/api
    description: Production

paths:
  /auth/register:
    post:
      summary: Register new user
      tags: [Authentication]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [email, password, firstName, lastName]
              properties:
                email:
                  type: string
                  format: email
                password:
                  type: string
                  minLength: 8
                firstName:
                  type: string
                lastName:
                  type: string
                fitnessLevel:
                  type: string
                  enum: [Beginner, Intermediate, Advanced]
      responses:
        '201':
          description: User created successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AuthResponse'
        '400':
          description: Invalid input

  /auth/login:
    post:
      summary: Login user
      tags: [Authentication]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [email, password]
              properties:
                email:
                  type: string
                password:
                  type: string
      responses:
        '200':
          description: Login successful
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AuthResponse'
        '401':
          description: Invalid credentials

  /classes:
    get:
      summary: Get list of classes
      tags: [Classes]
      parameters:
        - name: page
          in: query
          schema:
            type: integer
            default: 1
        - name: pageSize
          in: query
          schema:
            type: integer
            default: 20
        - name: type
          in: query
          schema:
            type: string
        - name: date
          in: query
          schema:
            type: string
            format: date
      responses:
        '200':
          description: List of classes
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: array
                    items:
                      $ref: '#/components/schemas/Class'
                  pagination:
                    $ref: '#/components/schemas/Pagination'

  /recommendations/{userId}:
    get:
      summary: Get personalized recommendations
      tags: [Recommendations]
      security:
        - bearerAuth: []
      parameters:
        - name: userId
          in: path
          required: true
          schema:
            type: string
        - name: type
          in: query
          schema:
            type: string
            default: all
        - name: limit
          in: query
          schema:
            type: integer
            default: 10
      responses:
        '200':
          description: List of recommendations
          content:
            application/json:
              schema:
                type: object
                properties:
                  userId:
                    type: string
                  recommendations:
                    type: array
                    items:
                      $ref: '#/components/schemas/Recommendation'
                  generatedAt:
                    type: string
                    format: date-time

  /events:
    post:
      summary: Track user event
      tags: [Events]
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Event'
      responses:
        '202':
          description: Event accepted for processing

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT

  schemas:
    AuthResponse:
      type: object
      properties:
        token:
          type: string
        user:
          $ref: '#/components/schemas/User'
        expiresAt:
          type: string
          format: date-time

    User:
      type: object
      properties:
        id:
          type: string
        email:
          type: string
        firstName:
          type: string
        lastName:
          type: string
        fitnessLevel:
          type: string
        segment:
          type: string

    Class:
      type: object
      properties:
        id:
          type: string
        name:
          type: string
        type:
          type: string
        description:
          type: string
        instructorName:
          type: string
        startTime:
          type: string
          format: date-time
        durationMinutes:
          type: integer
        capacity:
          type: integer
        currentEnrollment:
          type: integer
        averageRating:
          type: number
        difficultyLevel:
          type: string

    Recommendation:
      type: object
      properties:
        itemId:
          type: string
        itemType:
          type: string
        score:
          type: number
        reason:
          type: string
        class:
          $ref: '#/components/schemas/Class'

    Event:
      type: object
      required: [userId, itemId, eventType]
      properties:
        userId:
          type: string
        itemId:
          type: string
        itemType:
          type: string
        eventType:
          type: string
          enum: [View, Click, Book, Complete, Cancel]
        timestamp:
          type: string
          format: date-time
        metadata:
          type: object

    Pagination:
      type: object
      properties:
        page:
          type: integer
        pageSize:
          type: integer
        totalPages:
          type: integer
        totalItems:
          type: integer
```

---

# **7. DATABASE SCHEMA (SQL)**

```sql
-- Create database
CREATE DATABASE FitLifeDB;
GO

USE FitLifeDB;
GO

-- Users table
CREATE TABLE Users (
    Id NVARCHAR(50) PRIMARY KEY,
    Email NVARCHAR(255) UNIQUE NOT NULL,
    PasswordHash NVARCHAR(255) NOT NULL,
    FirstName NVARCHAR(100) NOT NULL,
    LastName NVARCHAR(100) NOT NULL,
    FitnessLevel NVARCHAR(20) DEFAULT 'Beginner',
    Goals NVARCHAR(MAX), -- JSON array
    PreferredClassTypes NVARCHAR(MAX), -- JSON array
    FavoriteInstructors NVARCHAR(MAX), -- JSON array
    Segment NVARCHAR(50) DEFAULT 'General',
    CreatedAt DATETIME2 DEFAULT GETUTCDATE(),
    UpdatedAt DATETIME2 DEFAULT GETUTCDATE()
);

CREATE INDEX IX_Users_Email ON Users(Email);
CREATE INDEX IX_Users_Segment ON Users(Segment);

-- Classes table
CREATE TABLE Classes (
    Id NVARCHAR(50) PRIMARY KEY,
    Name NVARCHAR(255) NOT NULL,
    Type NVARCHAR(50) NOT NULL,
    Description NVARCHAR(MAX),
    InstructorId NVARCHAR(50) NOT NULL,
    InstructorName NVARCHAR(255) NOT NULL,
    LocationId NVARCHAR(50) DEFAULT 'default',
    LocationName NVARCHAR(255),
    StartTime DATETIME2 NOT NULL,
    DurationMinutes INT NOT NULL,
    Capacity INT NOT NULL,
    CurrentEnrollment INT DEFAULT 0,
    AverageRating DECIMAL(3,2) DEFAULT 0,
    DifficultyLevel NVARCHAR(50) DEFAULT 'All Levels',
    ImageUrl NVARCHAR(500),
    IsActive BIT DEFAULT 1,
    CreatedAt DATETIME2 DEFAULT GETUTCDATE()
);

CREATE INDEX IX_Classes_StartTime ON Classes(StartTime);
CREATE INDEX IX_Classes_Type ON Classes(Type);
CREATE INDEX IX_Classes_InstructorId ON Classes(InstructorId);

-- Interactions table (event store)
CREATE TABLE Interactions (
    Id NVARCHAR(50) PRIMARY KEY,
    UserId NVARCHAR(50) NOT NULL,
    ItemId NVARCHAR(50) NOT NULL,
    ItemType NVARCHAR(20) NOT NULL,
    EventType NVARCHAR(20) NOT NULL,
    Timestamp DATETIME2 DEFAULT GETUTCDATE(),
    Metadata NVARCHAR(MAX), -- JSON
    FOREIGN KEY (UserId) REFERENCES Users(Id)
);

CREATE INDEX IX_Interactions_UserId_Timestamp ON Interactions(UserId, Timestamp DESC);
CREATE INDEX IX_Interactions_ItemId ON Interactions(ItemId);
CREATE INDEX IX_Interactions_EventType ON Interactions(EventType);

-- Recommendations table (precomputed)
CREATE TABLE Recommendations (
    UserId NVARCHAR(50) NOT NULL,
    ItemId NVARCHAR(50) NOT NULL,
    ItemType NVARCHAR(20) NOT NULL,
    Score FLOAT NOT NULL,
    Rank INT NOT NULL,
    Reason NVARCHAR(500),
    GeneratedAt DATETIME2 DEFAULT GETUTCDATE(),
    PRIMARY KEY (UserId, ItemId),
    FOREIGN KEY (UserId) REFERENCES Users(Id)
);

CREATE INDEX IX_Recommendations_UserId_Rank ON Recommendations(UserId, Rank);
CREATE INDEX IX_Recommendations_GeneratedAt ON Recommendations(GeneratedAt);

-- Seed data for classes
INSERT INTO Classes (Id, Name, Type, Description, InstructorId, InstructorName, LocationId, LocationName, StartTime, DurationMinutes, Capacity, CurrentEnrollment, AverageRating, DifficultyLevel, ImageUrl, IsActive)
VALUES
('class_001', 'Vinyasa Flow Yoga', 'Yoga', 'Dynamic yoga practice connecting breath with movement', 'inst_sarah', 'Sarah Johnson', 'loc_uptown', 'Minneapolis - Uptown', '2025-10-31 18:00:00', 60, 25, 12, 4.8, 'All Levels', '/images/yoga.jpg', 1),
('class_002', 'HIIT Blast', 'HIIT', 'High-intensity interval training for maximum calorie burn', 'inst_mike', 'Mike Thompson', 'loc_uptown', 'Minneapolis - Uptown', '2025-10-31 06:00:00', 45, 30, 28, 4.9, 'Intermediate', '/images/hiit.jpg', 1),
('class_003', 'Spin Revolution', 'Spin', 'Indoor cycling with energizing music and hills', 'inst_lisa', 'Lisa Martinez', 'loc_downtown', 'Minneapolis - Downtown', '2025-10-31 17:30:00', 50, 35, 20, 4.7, 'All Levels', '/images/spin.jpg', 1),
('class_004', 'Power Pilates', 'Pilates', 'Core-focused workout for strength and flexibility', 'inst_emily', 'Emily Chen', 'loc_uptown', 'Minneapolis - Uptown', '2025-11-01 12:00:00', 55, 20, 8, 4.6, 'Beginner', '/images/pilates.jpg', 1),
('class_005', 'Strength & Conditioning', 'Strength', 'Full-body strength training with free weights', 'inst_david', 'David Wilson', 'loc_downtown', 'Minneapolis - Downtown', '2025-11-01 18:00:00', 60, 25, 15, 4.8, 'Intermediate', '/images/strength.jpg', 1),
('class_006', 'Restorative Yoga', 'Yoga', 'Gentle, relaxing yoga for recovery and stress relief', 'inst_sarah', 'Sarah Johnson', 'loc_uptown', 'Minneapolis - Uptown', '2025-11-02 10:00:00', 75, 20, 5, 4.9, 'Beginner', '/images/restorative.jpg', 1),
('class_007', 'Bootcamp Challenge', 'HIIT', 'Military-style bootcamp for serious fat burning', 'inst_mike', 'Mike Thompson', 'loc_downtown', 'Minneapolis - Downtown', '2025-11-02 06:30:00', 60, 30, 25, 4.8, 'Advanced', '/images/bootcamp.jpg', 1),
('class_008', 'Barre Fusion', 'Barre', 'Ballet-inspired workout combining pilates and yoga', 'inst_emily', 'Emily Chen', 'loc_uptown', 'Minneapolis - Uptown', '2025-11-02 09:00:00', 55, 20, 10, 4.7, 'All Levels', '/images/barre.jpg', 1);

-- More seed data (instructors, locations, etc.) can be added similarly
```

---

# **8. INFRASTRUCTURE & DEVOPS**

## **8.1 Docker Compose (Local Development)**

```yaml
version: '3.8'

services:
  # SQL Server
  sqlserver:
    image: mcr.microsoft.com/mssql/server:2022-latest
    container_name: fitlife-sqlserver
    environment:
      - ACCEPT_EULA=Y
      - SA_PASSWORD=YourStrong@Passw0rd
      - MSSQL_PID=Express
    ports:
      - "1433:1433"
    volumes:
      - sqlserver-data:/var/opt/mssql
    healthcheck:
      test: /opt/mssql-tools/bin/sqlcmd -S localhost -U sa -P YourStrong@Passw0rd -Q "SELECT 1"
      interval: 30s
      timeout: 10s
      retries: 5

  # Redis
  redis:
    image: redis:7-alpine
    container_name: fitlife-redis
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    command: redis-server --appendonly yes
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 3

  # Zookeeper (required for Kafka)
  zookeeper:
    image: confluentinc/cp-zookeeper:7.5.0
    container_name: fitlife-zookeeper
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
    ports:
      - "2181:2181"

  # Kafka
  kafka:
    image: confluentinc/cp-kafka:7.5.0
    container_name: fitlife-kafka
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
      - "9093:9093"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9093,PLAINTEXT_HOST://localhost:9092
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_AUTO_CREATE_TOPICS_ENABLE: "true"
    healthcheck:
      test: kafka-topics --bootstrap-server localhost:9093 --list
      interval: 30s
      timeout: 10s
      retries: 3

  # .NET API
  api:
    build:
      context: ./FitLife.Api
      dockerfile: Dockerfile
    container_name: fitlife-api
    depends_on:
      - sqlserver
      - redis
      - kafka
    ports:
      - "8080:8080"
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ASPNETCORE_URLS=http://+:8080
      - ConnectionStrings__DefaultConnection=Server=sqlserver;Database=FitLifeDB;User Id=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=True
      - Redis__ConnectionString=redis:6379
      - Kafka__BootstrapServers=kafka:9093
      - Jwt__Secret=YourSuperSecretKeyThatIsAtLeast32CharactersLong!
      - Jwt__Issuer=FitLifeApi
      - Jwt__Audience=FitLifeClient
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Vue.js Frontend
  web:
    build:
      context: ./fitlife-web
      dockerfile: Dockerfile
    container_name: fitlife-web
    depends_on:
      - api
    ports:
      - "3000:80"
    environment:
      - VITE_API_BASE_URL=http://localhost:8080/api

volumes:
  sqlserver-data:
  redis-data:

networks:
  default:
    name: fitlife-network
```

---

## **8.2 Kubernetes Deployment Example**

```yaml
# api-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: fitlife-api
  labels:
    app: fitlife-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: fitlife-api
  template:
    metadata:
      labels:
        app: fitlife-api
    spec:
      containers:
      - name: api
        image: yourregistry.azurecr.io/fitlife-api:latest
        ports:
        - containerPort: 8080
        env:
        - name: ASPNETCORE_ENVIRONMENT
          value: "Production"
        - name: ConnectionStrings__DefaultConnection
          valueFrom:
            secretKeyRef:
              name: fitlife-secrets
              key: sql-connection-string
        - name: Redis__ConnectionString
          valueFrom:
            configMapKeyRef:
              name: fitlife-config
              key: redis-connection
        - name: Kafka__BootstrapServers
          valueFrom:
            configMapKeyRef:
              name: fitlife-config
              key: kafka-servers
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 8080
          initialDelaySeconds: 15
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: fitlife-api-service
spec:
  selector:
    app: fitlife-api
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: ClusterIP
```

---

# **9. TESTING STRATEGY**

## **9.1 Backend Tests**

```csharp
// Example unit test for ScoringEngine
public class ScoringEngineTests
{
    [Fact]
    public void CalculateScore_PreferredClassType_ShouldBoostScore()
    {
        // Arrange
        var engine = new ScoringEngine();
        var user = new User
        {
            PreferredClassTypes = JsonSerializer.Serialize(new[] { "Yoga", "Pilates" }),
            FitnessLevel = "Intermediate"
        };
        var yogaClass = new Class
        {
            Type = "Yoga",
            DifficultyLevel = "Intermediate",
            AverageRating = 4.5m
        };
        
        // Act
        var score = engine.CalculateScore(user, yogaClass);
        
        // Assert
        Assert.True(score > 20); // Base score + preferred type bonus
    }
}

// Example integration test
public class RecommendationsControllerTests : IClassFixture<WebApplicationFactory<Program>>
{
    private readonly HttpClient _client;
    
    public RecommendationsControllerTests(WebApplicationFactory<Program> factory)
    {
        _client = factory.CreateClient();
    }
    
    [Fact]
    public async Task GetRecommendations_AuthenticatedUser_ReturnsRecommendations()
    {
        // Arrange
        var token = await GetAuthToken();
        _client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", token);
        
        // Act
        var response = await _client.GetAsync("/api/recommendations/user_123?limit=5");
        
        // Assert
        response.EnsureSuccessStatusCode();
        var content = await response.Content.ReadAsStringAsync();
        var result = JsonSerializer.Deserialize<RecommendationResponse>(content);
        Assert.NotNull(result);
        Assert.NotEmpty(result.Recommendations);
    }
}
```

---

## **9.2 Frontend Tests**

```typescript
// Example component test with Vitest
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import ClassCard from '@/components/classes/ClassCard.vue'

describe('ClassCard', () => {
  it('displays class information correctly', () => {
    const classData = {
      id: 'class_001',
      name: 'Vinyasa Flow Yoga',
      instructorName: 'Sarah Johnson',
      startTime: '2025-10-31T18:00:00Z',
      durationMinutes: 60,
      type: 'Yoga',
      capacity: 25,
      currentEnrollment: 12
    }
    
    const wrapper = mount(ClassCard, {
      props: { class: classData }
    })
    
    expect(wrapper.text()).toContain('Vinyasa Flow Yoga')
    expect(wrapper.text()).toContain('Sarah Johnson')
    expect(wrapper.text()).toContain('13 spots left')
  })
  
  it('emits book event when button clicked', async () => {
    const wrapper = mount(ClassCard, {
      props: { class: mockClassData }
    })
    
    await wrapper.find('.book-button').trigger('click')
    
    expect(wrapper.emitted('book')).toBeTruthy()
  })
})
```

---

# **10. DEMO SCENARIOS**

## **Scenario 1: New User Journey**
1. User registers with email/password
2. Selects fitness level: "Beginner"
3. Sets goals: "Weight loss", "Build strength"
4. Views dashboard (empty state - no recommendations yet)
5. Browses classes
6. Clicks on "Vinyasa Flow Yoga" (View event tracked)
7. Books the class (Book event tracked)
8. Returns to dashboard
9. Sees personalized recommendations (based on yoga booking)

## **Scenario 2: Active User Gets Better Recommendations**
1. User logs in (already has 15+ classes completed)
2. Dashboard shows:
   - "You're on a 3-week streak! ğŸ”¥"
   - Segment: "Highly Active"
   - Recent classes: mostly yoga and pilates
3. Recommendations feed shows:
   - More yoga/pilates classes
   - Similar instructors
   - Classes at user's preferred times (evenings)
   - Reason: "Because you love yoga classes with Sarah"
4. User clicks "Refresh Recommendations"
5. New recommendations generated in real-time

## **Scenario 3: Admin Manages Classes**
1. Admin logs in
2. Navigates to Admin Panel
3. Creates new class:
   - Name: "Sunrise Meditation"
   - Type: Yoga
   - Instructor: Sarah Johnson
   - Time: Tomorrow 6:00 AM
4. Class appears in catalog immediately
5. Recommendation engine picks it up in next batch run
6. Yoga enthusiasts see it in their feed

---

# **ğŸ“Š METRICS FOR SUCCESS**

Track these metrics to demo system effectiveness:

1. **API Performance:**
   - P50 latency: <100ms
   - P95 latency: <200ms
   - Cache hit rate: >90%

2. **Recommendation Quality:**
   - Click-through rate: >15%
   - Booking conversion rate: >5%
   - Average score of booked classes: >70

3. **System Health:**
   - API uptime: 99.9%
   - Kafka consumer lag: <1 minute
   - Database query time: <50ms

4. **User Engagement:**
   - Daily active users
   - Classes booked per user
   - Time spent in app

---

# **ğŸ¯ FINAL CHECKLIST FOR INTERVIEW**

Before presenting this project:

- [ ] Application runs locally via Docker Compose
- [ ] All API endpoints work (test with Postman)
- [ ] Frontend displays data correctly
- [ ] User can register, login, browse classes
- [ ] Recommendations appear after interactions
- [ ] Events flow through Kafka
- [ ] Background services process events
- [ ] Code is well-commented and clean
- [ ] README has clear setup instructions
- [ ] Architecture diagram is ready to present
- [ ] Can explain trade-offs and design decisions
- [ ] Know how to scale each component
- [ ] Prepared to discuss alternatives (SQL vs NoSQL, etc.)
- [ ] Demo video recorded (5-10 minutes)
- [ ] GitHub repo is public and polished

---

# **ğŸš€ QUICK START COMMANDS**

```bash
# Clone and setup
git clone https://github.com/yourusername/fitlife-app
cd fitlife-app

# Start all services with Docker Compose
docker-compose up -d

# Check logs
docker-compose logs -f api

# Run database migrations
cd FitLife.Api
dotnet ef database update

# Seed sample data
dotnet run --seed

# Start frontend (separate terminal)
cd ../fitlife-web
npm install
npm run dev

# Run tests
dotnet test                    # Backend
npm run test                   # Frontend

# Access application
# Frontend: http://localhost:3000
# API: http://localhost:8080
# Swagger: http://localhost:8080/swagger
```

---

This comprehensive package gives you everything needed to build a production-ready gym personalization application that directly aligns with the Life Time Fitness role requirements. Each prompt is designed for Code Pilot Claude to implement independently, and the entire system demonstrates senior-level full-stack engineering skills.